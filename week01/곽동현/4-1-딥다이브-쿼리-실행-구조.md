# 4.1 MySQL 쿼리 실행 구조 Deep Dive

## 전체 흐름 개요

하나의 SQL이 결과를 돌려주기까지, 다음 단계를 거친다.

```
클라이언트 (JDBC 등)
    │
    ▼
┌─────────────────────────────────────────────┐
│             MySQL 엔진 영역                   │
│                                             │
│  ① 커넥션 핸들러  (스레드 할당)                  │
│         │                                   │
│         ▼                                   │
│  ② 쿼리 파서     (SQL → 파서 트리)             │
│         │                                   │
│         ▼                                   │
│  ③ 전처리기      (유효성 검증 + 권한 확인)        │
│         │                                   │
│         ▼                                   │
│  ④ 옵티마이저    (실행 계획 수립)                │
│         │                                   │
│         ▼                                   │
│  ⑤ 실행 엔진     (계획에 따라 핸들러에 명령)      │
│         │                                   │
└─────────┼───────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────┐
│          스토리지 엔진 영역                     │
│                                             │
│  ⑥ 핸들러       (실제 디스크/버퍼 I/O)          │
│                                             │
└─────────────────────────────────────────────┘
```

---

## ① 커넥션 핸들러 - "누가 이 쿼리를 처리할 것인가"

클라이언트가 MySQL에 접속하면, 가장 먼저 일어나는 일은 **포그라운드 스레드 할당**이다.

```
[Java 애플리케이션]
    │
    │  JDBC Connection 요청
    ▼
[MySQL 서버]
    │
    ├─ 스레드 캐시에 여유 스레드가 있으면 → 꺼내서 할당
    │
    └─ 없으면 → 새 스레드 생성해서 할당
```

> **Java 비유**: Tomcat의 스레드 풀에서 워커 스레드 하나를 꺼내 HTTP 요청에 배정하는 것과 같다. MySQL도 **1 커넥션 = 1 포그라운드 스레드**다.

이 스레드가 이제부터 아래의 모든 과정을 책임진다.

---

## ② 쿼리 파서 (Query Parser) - "SQL 문장을 해체한다"

사용자가 이런 쿼리를 보냈다고 가정하자.

```sql
SELECT name, age FROM member WHERE m_id = 12;
```

쿼리 파서는 이 **SQL 문자열을 토큰(Token)으로 분리**하고, **파서 트리(Parse Tree)**라는 구조로 변환한다.

```
          [SELECT Statement]
         /        |         \
    [columns]  [FROM]    [WHERE]
     /    \       |         |
  name   age   member   [조건식]
                          |
                     m_id = 12
```

이 단계에서 하는 일은 딱 하나: **SQL 문법이 맞는지 확인**.

```sql
-- 이런 건 여기서 잡힌다
SELEC name FROM member;  -- "SELEC"은 SQL 키워드가 아님 → 문법 에러!
```

하지만 `member`라는 테이블이 실제로 존재하는지, `name`이라는 컬럼이 있는지는 **전혀 확인하지 않는다**. 그건 다음 단계의 역할이다.

> **Java 비유**: 컴파일러의 **구문 분석(Syntax Analysis)** 단계와 같다. `javac`가 `.java` 파일을 AST(Abstract Syntax Tree)로 변환하는 것처럼, MySQL 파서도 SQL을 트리 구조로 만든다.

---

## ③ 전처리기 (Preprocessor) - "진짜 존재하는 것들인지 검증한다"

파서 트리가 만들어지면, 전처리기가 이 트리를 받아서 **의미적(Semantic) 검증**을 수행한다.

**하는 일:**
1. **테이블 존재 여부 확인** → `member` 테이블이 실제로 있는가?
2. **컬럼 존재 여부 확인** → `name`, `age`, `m_id` 컬럼이 `member`에 있는가?
3. **내장 함수 매핑** → `COUNT()`, `NOW()` 같은 함수가 올바르게 사용됐는가?
4. **접근 권한 확인** → 현재 사용자가 이 테이블을 SELECT 할 권한이 있는가?

```sql
-- 파서는 통과하지만, 전처리기에서 잡히는 경우들
SELECT name FROM memberrrr;     -- 테이블 없음!
SELECT nickname FROM member;    -- 컬럼 없음!
```

> **Java 비유**: 컴파일러의 **시맨틱 분석(Semantic Analysis)** 단계다. 문법은 맞지만 `존재하지 않는 클래스를 참조`하거나 `private 메서드에 접근`하려 할 때 컴파일 에러가 나는 것과 같은 원리다.

---

## ④ 옵티마이저 (Optimizer) - "가장 빠른 길을 찾는다"

**MySQL의 두뇌**. 쿼리를 **어떻게** 실행할지 결정하는 단계.

같은 결과를 내는 방법이 여러 가지일 수 있다:

```sql
SELECT name, age FROM member WHERE m_id = 12;
```

- **방법 A**: 테이블 전체를 처음부터 끝까지 읽으면서 m_id=12인 행을 찾는다 (Full Table Scan)
- **방법 B**: m_id에 인덱스가 있으면, 인덱스를 타고 바로 해당 레코드로 간다 (Index Scan)

옵티마이저는 **통계 정보(테이블의 레코드 수, 인덱스 분포도 등)** 를 기반으로 각 방법의 **비용(Cost)**을 계산하고, 가장 저렴한 방법을 선택한다.

```
옵티마이저의 판단 과정 (개념적):

방법 A: Full Table Scan
  - member 테이블 전체 레코드 수: 100만 건
  - 예상 비용: 100만 행 읽기 → 비용 높음

방법 B: PK Index Lookup
  - m_id는 Primary Key → B-Tree 인덱스 존재
  - 예상 비용: 트리 탐색 3~4회 → 비용 매우 낮음

→ 방법 B 선택!
```

**옵티마이저가 결정하는 것들:**
- 어떤 인덱스를 사용할지 (또는 인덱스를 안 쓸지)
- 테이블 조인 순서를 어떻게 할지 (A→B 조인 vs B→A 조인)
- 임시 테이블을 사용할지
- 정렬을 인덱스로 할지, 별도 소트 버퍼로 할지

이 결정 결과가 바로 **실행 계획(Execution Plan)**이다. `EXPLAIN` 명령어로 확인할 수 있다:

```sql
EXPLAIN SELECT name, age FROM member WHERE m_id = 12;
```

> **Java 비유**: Spring의 `HandlerMapping`과 비슷하면서도 훨씬 더 복잡한 역할이다. HandlerMapping은 "어떤 컨트롤러가 처리할지"만 결정하지만, 옵티마이저는 "어떤 경로로, 어떤 순서로, 어떤 알고리즘으로 처리할지"까지 전부 결정한다.

---

## ⑤ 실행 엔진 (Query Execution Engine) - "계획을 실행으로 옮기는 중간 관리자"

옵티마이저가 계획을 세웠으면, 실행 엔진이 그 계획을 **한 단계씩 핸들러에게 지시**한다.

### 단순 조회 예시

```
실행 엔진 → 핸들러: "member 테이블의 PK 인덱스에서 m_id=12를 찾아줘"
핸들러 → 실행 엔진: "찾았어, 여기 레코드야"
실행 엔진 → 클라이언트: "결과 반환"
```

### 조인이 포함된 복잡한 예시

```sql
SELECT m.name, o.order_date
FROM member m
JOIN orders o ON m.m_id = o.member_id
WHERE m.age > 25;
```

```
실행 엔진 → 핸들러: "member에서 age > 25인 첫 번째 레코드 읽어줘"
핸들러 → 실행 엔진: "{m_id=3, name='Kim', age=28}"

실행 엔진 → 핸들러: "orders에서 member_id=3인 레코드 찾아줘"
핸들러 → 실행 엔진: "{order_date='2026-01-15'}"

실행 엔진: 결과 세트에 (Kim, 2026-01-15) 추가

실행 엔진 → 핸들러: "member에서 age > 25인 다음 레코드 읽어줘"
핸들러 → 실행 엔진: "{m_id=7, name='Lee', age=32}"

실행 엔진 → 핸들러: "orders에서 member_id=7인 레코드 찾아줘"
...반복...
```

**핵심: 실행 엔진은 직접 데이터를 건드리지 않는다.** 항상 핸들러에게 요청하고, 핸들러가 돌려준 결과를 **다음 핸들러 요청의 입력으로 연결**하는 역할만 한다.

> **역할 비유**:
> - **옵티마이저** = 경영진 (전략을 세움)
> - **실행 엔진** = 중간 관리자 (지시를 전달하고 결과를 조율)
> - **핸들러** = 실무자 (실제 작업 수행)

---

## ⑥ 핸들러 (Handler = 스토리지 엔진) - "실제로 데이터를 읽고 쓰는 실무자"

핸들러는 **MySQL 엔진과 스토리지 엔진 사이의 인터페이스**다.

실행 엔진이 "이 레코드 읽어줘"라고 하면, InnoDB 스토리지 엔진이 실제로 동작하는 순서:

```
실행 엔진의 요청: "PK=12인 레코드를 읽어라"
    │
    ▼
[InnoDB 버퍼 풀에 해당 페이지가 있는가?]
    │
    ├─ YES → 버퍼 풀에서 바로 반환 (메모리 읽기, 매우 빠름)
    │
    └─ NO  → 디스크에서 페이지를 버퍼 풀로 로드 → 반환 (디스크 I/O, 느림)
```

**스레딩 구조(4.1.2)와의 연결:**
- **읽기**: 포그라운드 스레드가 직접 버퍼 풀/디스크에서 읽음
- **쓰기**: 포그라운드 스레드가 버퍼 풀까지만 변경하고, **실제 디스크 기록은 백그라운드 스레드가 처리**

이것이 MySQL이 빠른 이유 중 하나다. 쓰기 요청이 와도 디스크 쓰기를 기다리지 않고 버퍼 풀만 업데이트하면 클라이언트에게 바로 응답할 수 있다.

---

## 전체 흐름 시나리오: Java 애플리케이션에서 쿼리 실행까지

```java
// Spring Repository
@Query("SELECT name, age FROM member WHERE m_id = :id")
Member findById(@Param("id") Long id);
```

```
 1. [HikariCP] 커넥션 풀에서 MySQL 커넥션 획득

 2. [JDBC Driver] SQL 문자열을 MySQL 서버로 전송

 3. [커넥션 핸들러] 이미 할당된 포그라운드 스레드가 쿼리 수신

 4. [쿼리 파서] "SELECT name, age FROM member WHERE m_id = 12"
                → 토큰 분리 → 파서 트리 생성
                → 문법 오류 없음 ✓

 5. [전처리기] 파서 트리 검증
              → member 테이블 존재? ✓
              → name, age, m_id 컬럼 존재? ✓
              → SELECT 권한 있음? ✓

 6. [옵티마이저] 실행 계획 수립
                → m_id는 PK → PK 인덱스 사용 결정
                → 비용: 매우 낮음 (1건 조회)

 7. [실행 엔진] 핸들러에게 지시
               → "InnoDB야, PK=12 레코드 읽어줘"

 8. [핸들러/InnoDB]
                → 버퍼 풀 확인 → 있으면 바로 반환
                               → 없으면 디스크 → 버퍼 풀 → 반환

 9. [실행 엔진] 결과를 클라이언트에게 전달

10. [JDBC Driver] ResultSet으로 변환 → Java 객체 매핑
```

---

## 학습 질문 1: 옵티마이저의 오판

> **Q. 옵티마이저가 잘못된 판단을 내릴 수도 있을까?**
> 예를 들어 인덱스가 있는데도 Full Table Scan을 선택한다거나, 반대로 인덱스를 쓰는 게 오히려 더 느린 경우도 있을까?

---

## 옵티마이저는 완벽하지 않다

옵티마이저는 **"실제로 실행해보고"** 판단하는 게 아니다. **통계 정보를 기반으로 비용을 추정**해서 판단한다. 즉, **예측**이다.

```
현실 세계:  실제 데이터 분포, 실제 디스크 상태, 실제 캐시 상태
                    │
                    ▼
옵티마이저가 보는 것:  통계 정보 (근사치, 샘플링 기반)
                    │
                    ▼
                 비용 추정 → 실행 계획 결정
```

> **Java 비유**: 네비게이션이 "평균 교통량" 데이터를 보고 경로를 추천하는 것과 같다. 실시간 상황과 다를 수 있다.

이 "예측 vs 현실"의 간극에서 잘못된 판단이 발생한다.

---

### Case 1: 통계 정보가 오래됐을 때

옵티마이저의 판단 근거는 **테이블 통계**다. InnoDB는 통계를 **샘플링 방식**으로 수집한다.

```sql
-- 테이블의 통계 정보 확인
SHOW TABLE STATUS LIKE 'member';
```

문제 상황:

```
[상황]
- 어제까지 member 테이블: 1,000건
- 오늘 배치로 대량 INSERT: 1,000,000건 추가
- 하지만 통계 정보는 아직 갱신 안 됨

[옵티마이저의 판단]
"member는 1,000건짜리 작은 테이블이네? Full Table Scan이 인덱스보다 빠르겠다"

[현실]
실제로는 100만 건이라 Full Table Scan은 재앙
```

이런 경우 수동으로 통계를 갱신해줘야 한다:

```sql
ANALYZE TABLE member;
```

> **Java 비유**: Spring에서 `@Cacheable`로 캐싱한 데이터가 DB와 달라진 상황과 비슷하다. 캐시(통계)가 현실(실제 데이터)을 반영하지 못하는 것이다.

---

### Case 2: 인덱스를 쓰는 게 오히려 느린 경우

**"인덱스가 있으면 무조건 빠르다"는 틀린 말**이다.

```sql
-- 상황: member 테이블에 100만 건, gender 컬럼에 인덱스 있음
-- gender는 'M' 또는 'F' 두 가지 값만 존재

SELECT * FROM member WHERE gender = 'M';
```

```
[인덱스를 사용하면?]

  인덱스(gender)         테이블 데이터(디스크)
  ┌──────────┐          ┌──────────────────┐
  │ F → 위치1 │ ───────→ │ 페이지 37        │  ← 랜덤 I/O
  │ F → 위치2 │ ───────→ │ 페이지 152       │  ← 랜덤 I/O
  │ M → 위치3 │ ───────→ │ 페이지 8         │  ← 랜덤 I/O
  │ M → 위치4 │ ───────→ │ 페이지 891       │  ← 랜덤 I/O
  │ ...50만건  │          │ ...              │
  └──────────┘          └──────────────────┘

  50만 건 × 랜덤 디스크 I/O = 매우 느림!

[Full Table Scan이면?]

  테이블 데이터(디스크)
  ┌──────────────────┐
  │ 페이지 1  → 순차 읽기 │
  │ 페이지 2  → 순차 읽기 │
  │ 페이지 3  → 순차 읽기 │
  │ ...전체 순차 읽기      │
  └──────────────────┘

  순차 디스크 I/O = 훨씬 빠름!
```

핵심 원리:

```
랜덤 I/O (인덱스 경유)  vs  순차 I/O (Full Table Scan)

  랜덤 I/O: 디스크 헤드가 이리저리 왔다갔다 (HDD 기준 약 10ms/건)
  순차 I/O: 디스크 헤드가 한 방향으로 쭉 읽음 (HDD 기준 약 0.01ms/건)

  → 대략 1,000배 차이!
```

**조회 대상이 전체 데이터의 약 20~25% 이상**이면, 옵티마이저는 인덱스를 버리고 Full Table Scan을 선택하는 게 맞다. 이건 옳은 판단이다.

문제는 옵티마이저가 이 **비율을 잘못 추정**할 때 발생한다:

```
[옵티마이저 판단] "gender='M'인 건이 전체의 5%쯤 될 거야" → 인덱스 사용
[실제 데이터]     gender='M'인 건이 전체의 50% → 인덱스 쓰면 더 느림
```

---

### Case 3: 데이터 분포가 편향되어 있을 때

```sql
-- 상황: orders 테이블, status 컬럼에 인덱스 있음
-- 데이터 분포:
--   status = 'COMPLETED'  : 99만 건 (99%)
--   status = 'PENDING'    : 1만 건  (1%)

-- 쿼리 A
SELECT * FROM orders WHERE status = 'PENDING';
-- → 1만 건 (1%) → 인덱스 사용이 유리!

-- 쿼리 B
SELECT * FROM orders WHERE status = 'COMPLETED';
-- → 99만 건 (99%) → Full Table Scan이 유리!
```

그런데 옵티마이저가 보는 통계는 **평균적인 분포**일 수 있다:

```
[옵티마이저의 계산]
"status 컬럼의 고유값(cardinality) = 2"
"평균적으로 한 값당 50만 건쯤 되겠네"

→ 쿼리 A에 대해서도 "50만 건 나올 것 같으니 Full Table Scan하자"
→ 실제로는 1만 건뿐인데! 인덱스 쓰면 훨씬 빨랐을 텐데!
```

MySQL 8.0에서는 이 문제를 해결하기 위해 **히스토그램(Histogram)**을 도입했다:

```sql
-- 컬럼의 실제 데이터 분포를 수집
ANALYZE TABLE orders UPDATE HISTOGRAM ON status;
```

히스토그램이 있으면 옵티마이저는 "PENDING은 1%, COMPLETED는 99%"라는 **실제 분포**를 알 수 있다.

---

### Case 4: 복잡한 조인에서 순서를 잘못 잡을 때

```sql
SELECT *
FROM orders o
JOIN member m ON o.member_id = m.m_id
JOIN product p ON o.product_id = p.p_id
WHERE m.age > 25
  AND p.category = 'ELECTRONICS';
```

```
[방법 A] member 먼저 → orders → product
  age > 25인 member: 30만 건
  → 각각 orders 조인: 결과 100만 건
  → 각각 product 조인 + category 필터: 최종 5만 건

[방법 B] product 먼저 → orders → member
  category='ELECTRONICS'인 product: 100건
  → 각각 orders 조인: 결과 2만 건
  → 각각 member 조인 + age 필터: 최종 5만 건

방법 B가 압도적으로 빠름! (중간 결과 세트가 훨씬 작으니까)
```

옵티마이저가 각 조건의 **선택도(Selectivity)**를 잘못 추정하면, 방법 A를 선택해버릴 수 있다.

---

## 옵티마이저의 잘못된 판단을 교정하는 방법들

### 1. 통계 갱신

```sql
ANALYZE TABLE member;
ANALYZE TABLE orders;
```

### 2. EXPLAIN으로 실행 계획 확인

```sql
EXPLAIN SELECT name FROM member WHERE m_id = 12;

-- 더 상세한 정보
EXPLAIN ANALYZE SELECT name FROM member WHERE m_id = 12;
```

### 3. 힌트(Hint)로 옵티마이저 유도

```sql
-- "이 인덱스를 써라"고 강제
SELECT * FROM member USE INDEX (idx_age) WHERE age > 25;

-- "이 인덱스는 쓰지 마라"
SELECT * FROM member IGNORE INDEX (idx_age) WHERE age > 25;

-- "반드시 이 인덱스를 써라" (더 강력)
SELECT * FROM member FORCE INDEX (idx_age) WHERE age > 25;
```

### 4. 히스토그램 생성 (MySQL 8.0+)

```sql
ANALYZE TABLE orders UPDATE HISTOGRAM ON status WITH 100 BUCKETS;
```

---

## 정리: 옵티마이저가 틀리는 4가지 패턴

| 패턴 | 원인 | 해결 |
|------|------|------|
| 통계 정보 부정확 | 대량 데이터 변경 후 통계 미갱신 | `ANALYZE TABLE` |
| 인덱스 vs Full Scan 오판 | 랜덤 I/O vs 순차 I/O 비용 추정 실패 | 힌트 사용, 통계 갱신 |
| 데이터 분포 편향 | 평균 통계로 편향된 분포 대응 불가 | 히스토그램 |
| 조인 순서 오판 | 선택도 추정 실패 | 힌트, `STRAIGHT_JOIN` |

---

## 학습 질문 2: SSD와 I/O 패턴

> **Q. 랜덤 I/O와 순차 I/O의 성능 차이가 약 1,000배(HDD 기준)라고 했는데, 요즘 서버는 대부분 SSD를 사용한다.**
> SSD 환경에서는 "인덱스를 쓰는 게 오히려 느린 Case 2" 상황의 기준이 달라질까? 달라진다면 어떻게 달라질까?
