# MySQL 아키텍처 핵심 정리 (Real MySQL 8.0 - Chapter 4)

이 문서는 "Real MySQL 8.0" 책의 4장 아키텍처 부분을 정리한 내용입니다.

---

## 4.1 MySQL 엔진 아키텍처

### 4.1.2 MySQL 스레딩 구조

MySQL 서버는 **프로세스 기반이 아니라 스레드 기반**으로 작동합니다. 크게 **포그라운드(Foreground) 스레드**와 **백그라운드(Background) 스레드**로 나뉩니다.

`performance_schema.threads` 테이블을 통해 실행 중인 스레드 목록을 확인할 수 있으며, 예시에서는 전체 44개 스레드 중 41개가 백그라운드, 3개가 포그라운드로 표시되었습니다. 이 중 실제 사용자 요청을 처리하는 것은 `thread/sql/one_connection` 타입의 포그라운드 스레드뿐입니다.

**포그라운드 스레드 (= 클라이언트 스레드 = 사용자 스레드)**는 접속된 클라이언트 수만큼 존재하며, 각 클라이언트가 요청하는 쿼리를 처리합니다. 커넥션이 종료되면 스레드는 **스레드 캐시(Thread Cache)**로 돌아가고, 캐시에 이미 충분한 스레드가 있으면 종료됩니다. 스레드 캐시의 최대 크기는 `thread_cache_size` 시스템 변수로 설정합니다.

포그라운드 스레드는 데이터를 버퍼나 캐시에서 가져오고, 없으면 디스크에서 직접 읽어옵니다. InnoDB 테이블의 경우 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, **디스크에 기록하는 작업은 백그라운드 스레드가 담당**합니다. (MyISAM은 디스크 쓰기까지 포그라운드가 처리)

**백그라운드 스레드**는 InnoDB에서 특히 중요하며, 인서트 버퍼 병합, 로그 디스크 기록, InnoDB 버퍼 풀 데이터 디스크 기록, 데이터 버퍼 읽기, 잠금/데드락 모니터링 등의 작업을 수행합니다.

가장 중요한 것은 **로그 스레드(Log thread)**와 **쓰기 스레드(Write thread)**입니다. MySQL 5.5 버전부터 읽기/쓰기 스레드 개수를 2개 이상 지정할 수 있으며, `innodb_write_io_threads`와 `innodb_read_io_threads` 시스템 변수로 설정합니다. 일반적인 내장 디스크 사용 시 쓰기 스레드는 2~4개 정도가 적절합니다.

> **Java 개발자 관점에서 비유하자면**, 포그라운드 스레드는 Spring의 `@Controller`에서 HTTP 요청을 받아 처리하는 톰캣 워커 스레드에 해당하고, 백그라운드 스레드는 `@Async`로 비동기 처리되는 별도 스레드풀의 스레드와 비슷한 개념입니다.

---

### 4.1.3 메모리 할당 및 사용 구조

MySQL의 메모리 공간은 **글로벌 메모리 영역**과 **로컬(세션) 메모리 영역**으로 나뉩니다.

**글로벌 메모리 영역**은 MySQL 서버가 시작될 때 OS로부터 할당되며, 클라이언트 스레드 수와 무관하게 하나만 할당됩니다(필요에 따라 2개 이상일 수도 있지만 모든 스레드가 공유). 대표적으로 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼가 있습니다.

**로컬(세션) 메모리 영역**은 각 클라이언트 스레드별로 독립 할당되며 절대 공유되지 않습니다. 중요한 특징은 **각 쿼리의 용도별로 필요할 때만 할당**되고, 필요하지 않은 경우에는 할당조차 하지 않을 수 있다는 점입니다. 커넥션이 열려 있는 동안 계속 할당된 상태로 남는 공간(커넥션 버퍼, 결과 버퍼)도 있고, 쿼리를 실행하는 순간에만 할당했다가 해제하는 공간(소트 버퍼, 조인 버퍼)도 있습니다. 대표적으로 정렬 버퍼(Sort buffer), 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼가 있습니다.

> **Java 개발자 관점**: 글로벌 메모리는 JVM의 Heap에서 싱글톤으로 관리되는 공유 캐시(예: `ConcurrentHashMap` 기반 캐시)와 유사하고, 로컬 메모리는 각 요청 스레드의 `ThreadLocal` 변수처럼 스레드별로 격리된 공간과 비슷합니다.

---

### 4.1.4 플러그인 스토리지 엔진 모델

MySQL의 독특한 구조 중 하나가 **플러그인 모델**입니다. 스토리지 엔진뿐 아니라 검색어 파서, 인증(Native Authentication, Caching SHA-2 Authentication) 등도 플러그인으로 구현됩니다.

쿼리 실행 과정은 크게 **SQL 파서 → 옵티마이저 → SQL 실행기** (MySQL 엔진 처리 영역) → **데이터 읽기/쓰기** (스토리지 엔진 처리 영역)로 나뉩니다. 즉, 거의 대부분의 작업이 MySQL 엔진에서 처리되고, 마지막 데이터 읽기/쓰기만 스토리지 엔진이 담당합니다.

MySQL에서 **핸들러(Handler)**라는 단어를 자주 접하게 됩니다. MySQL 엔진이 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령할 때 반드시 핸들러를 통해야 합니다. `Handler_`로 시작하는 상태 변수는 MySQL 엔진이 스토리지 엔진에게 보낸 명령의 횟수를 의미합니다.

`SHOW ENGINES;` 명령으로 지원 스토리지 엔진을 확인할 수 있고, `SHOW PLUGINS;` 명령으로 스토리지 엔진뿐 아니라 인증, 검색용 파서 등 모든 플러그인을 확인할 수 있습니다.

---

### 4.1.5 컴포넌트

MySQL 8.0부터 기존 플러그인 아키텍처의 단점을 보완하기 위해 **컴포넌트 아키텍처**가 도입되었습니다. 플러그인의 단점은 MySQL 서버와만 인터페이스 가능(플러그인끼리 통신 불가), 서버 변수/함수 직접 호출로 인한 캡슐화 부재, 상호 의존 관계 설정 불가(초기화 어려움) 등이었습니다.

예를 들어 비밀번호 검증 기능은 MySQL 5.7까지 플러그인이었지만, 8.0에서는 컴포넌트(`component_validate_password`)로 개선되었습니다.

---

### 4.1.6 쿼리 실행 구조

쿼리 실행은 **쿼리 파서 → 전처리기 → 옵티마이저 → 실행 엔진 → 핸들러(스토리지 엔진)** 순서로 진행됩니다.

**쿼리 파서**는 SQL 문장을 토큰으로 분리해 파서 트리를 만들고, 기본 문법 오류를 검출합니다.

**전처리기**는 파서 트리를 기반으로 테이블 이름, 칼럼 이름, 내장 함수 등을 매핑하여 해당 객체의 존재 여부와 접근 권한을 확인합니다.

**옵티마이저**는 쿼리를 가장 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 DBMS의 두뇌입니다.

**실행 엔진**은 옵티마이저가 만든 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행합니다. (옵티마이저 = 경영진, 실행 엔진 = 중간 관리자, 핸들러 = 실무자로 비유)

**핸들러(스토리지 엔진)**는 MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할을 합니다.

---

### 4.1.8 쿼리 캐시

MySQL 8.0에서 **쿼리 캐시(Query Cache)는 완전히 제거**되었습니다. 쿼리 캐시는 SQL 실행 결과를 메모리에 캐시하여 동일 SQL 재실행 시 빠른 응답을 제공했지만, 테이블 데이터가 변경될 때마다 관련 캐시를 모두 삭제(Invalidate)해야 하는 심각한 동시 처리 성능 저하와 많은 버그의 원인이 되었기 때문입니다.

---

### 4.1.9 스레드 풀

MySQL 서버 엔터프라이즈 에디션은 스레드 풀(Thread Pool) 기능을 제공하지만, 커뮤니티 에디션은 지원하지 않습니다. 커뮤니티 에디션에서는 Percona Server의 스레드 풀 플러그인(`thread_pool.so`)을 설치하여 사용할 수 있습니다.

스레드 풀은 동시에 실행 중인 스레드들을 CPU가 최대한 잘 처리할 수 있는 수준으로 줄여서, CPU의 프로세서 친화도(Processor affinity)를 높이고 불필요한 컨텍스트 스위치를 줄이는 것이 목적입니다.

Percona Server의 스레드 풀은 기본적으로 CPU 코어 수만큼 스레드 그룹을 생성하며(`thread_pool_size`로 조정 가능), 각 그룹에서 새로운 작업 스레드를 추가할지 기존 작업 스레드의 완료를 기다릴지를 `thread_pool_stall_limit` 변수로 판단합니다. 또한 선순위 큐와 후순위 큐를 이용해 먼저 시작된 트랜잭션 내의 SQL을 우선 처리하여 잠금 경합을 줄이고 전체적인 처리 성능을 향상시킵니다.

---

### 4.1.10 트랜잭션 지원 메타데이터

MySQL 5.7 이전에는 테이블 구조 정보를 FRM 파일과 스토어드 프로그램/이벤트 정보를 별도 파일(`*.TRN`, `*.TRG`, `*.PAR` 등)로 관리했으나, 파일 기반이라 트랜잭션을 지원하지 않아 비정상 종료 시 일관성 문제가 발생했습니다.

**MySQL 8.0부터는 모든 메타데이터를 InnoDB 테이블에 트랜잭션 기반으로 저장**하도록 개선되었습니다. 이로써 스키마 변경 작업 중 비정상 종료되더라도 완전한 성공 또는 완전한 실패로 정리됩니다.

InnoDB 이외의 스토리지 엔진을 사용하는 테이블들에 대해서는 **SDI(Serialized Dictionary Information)** 파일(`*.sdi`)을 사용합니다. `ibd2sdi` 유틸리티를 이용하면 InnoDB 테이블스페이스에서 스키마 정보를 JSON으로 추출할 수 있습니다.

---

## 4.2 InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 **레코드 기반의 잠금**을 제공하며, 그 덕분에 높은 동시성 처리가 가능하고 안정적입니다.

### 4.2.1 프라이머리 키에 의한 클러스터링

InnoDB의 모든 테이블은 **프라이머리 키를 기준으로 클러스터링**되어 저장됩니다. 즉, 프라이머리 키 값의 순서대로 디스크에 저장됩니다. 모든 세컨더리 인덱스는 레코드의 물리적 주소 대신 **프라이머리 키의 값을 논리적인 주소로 사용**합니다. 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있으며, 실행 계획에서 프라이머리 키가 다른 보조 인덱스보다 선택될 확률이 높습니다.

이는 오라클의 IOT(Index Organized Table)와 동일한 구조이며, MyISAM과 달리 MyISAM은 클러스터링 키를 지원하지 않아 프라이머리 키와 세컨더리 인덱스 간 구조적 차이가 없습니다.

> **Java 개발자 관점**: JPA에서 `@Id`로 지정하는 PK가 단순한 식별자를 넘어 **물리적 데이터 저장 순서**를 결정한다고 이해하면 됩니다. 따라서 UUID 같은 랜덤 값보다 **Auto Increment 같은 순차적 값**을 PK로 사용하는 것이 InnoDB에서 훨씬 유리합니다.

---

### 4.2.2 외래 키 지원

외래 키는 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로, MyISAM이나 MEMORY 테이블에서는 사용할 수 없습니다. 외래 키 변경 시 부모/자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시 데이터 존재 여부를 체크해야 하므로 잠금이 여러 테이블로 전파되어 **데드락이 발생할 가능성**이 있습니다.

긴급 상황에서는 `foreign_key_checks` 시스템 변수를 `OFF`로 설정하여 외래 키 체크를 일시적으로 멈출 수 있지만, 작업 후 반드시 다시 `ON`으로 활성화하고 부모-자식 간 일관성을 맞춰야 합니다.

```sql
-- 외래 키 체크 일시 해제 (SESSION 범위)
SET foreign_key_checks=OFF;

-- 작업 수행 후 반드시 다시 활성화
SET foreign_key_checks=ON;
```

---

### 4.2.3 MVCC (Multi Version Concurrency Control)

MVCC는 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, 가장 큰 목적은 **잠금을 사용하지 않는 일관된 읽기를 제공**하는 것입니다. InnoDB는 **언두 로그(Undo log)**를 이용해 이 기능을 구현합니다.

예를 들어 `member` 테이블에 INSERT 후 COMMIT하면 InnoDB 버퍼 풀과 데이터 파일에 동일한 데이터가 존재합니다. 이후 UPDATE가 실행되면 InnoDB 버퍼 풀은 새로운 값으로 업데이트되고, **변경 전 값은 언두 로그에 복사**됩니다.

아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 같은 레코드를 조회하면, **격리 수준(Isolation Level)**에 따라 결과가 달라집니다.

`READ_UNCOMMITTED`에서는 InnoDB 버퍼 풀의 현재 변경된 데이터를 그대로 반환하고(커밋 여부와 무관), `READ_COMMITTED` 이상(`REPEATABLE_READ`, `SERIALIZABLE`)에서는 아직 커밋되지 않았으므로 **언두 영역의 변경 전 데이터를 반환**합니다.

COMMIT 시 InnoDB는 현재 상태를 영구 데이터로 만들고, ROLLBACK 시 언두 영역의 백업 데이터를 InnoDB 버퍼 풀로 복구한 뒤 언두 내용을 삭제합니다. 언두 영역의 백업 데이터는 해당 영역을 필요로 하는 트랜잭션이 더 없을 때 비로소 삭제됩니다.

> **Java 개발자 관점**: JPA의 `@Transactional(isolation = Isolation.READ_COMMITTED)` 설정이 바로 이 MVCC 메커니즘 위에서 동작합니다. 트랜잭션이 오래 열려 있으면 언두 로그가 계속 쌓여 테이블스페이스가 커질 수 있으므로, **트랜잭션은 가능한 한 빨리 커밋 또는 롤백**하는 것이 중요합니다.

---

### 4.2.4 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

InnoDB는 MVCC 기술로 잠금 없이 읽기 작업을 수행합니다. `SERIALIZABLE`이 아닌 격리 수준(`READ_UNCOMMITTED`, `READ_COMMITTED`, `REPEATABLE_READ`)에서는 순수한 읽기(SELECT) 작업이 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행됩니다.

특정 사용자가 레코드를 변경하고 아직 커밋하지 않았더라도, 다른 사용자의 SELECT 작업을 방해하지 않습니다. InnoDB에서는 변경되기 전의 데이터를 읽기 위해 **언두 로그**를 사용합니다.

다만, 오랜 시간 활성 상태인 트랜잭션으로 인해 일관된 읽기를 위한 언두 로그를 삭제하지 못하고 유지해야 하는 문제가 발생할 수 있으므로, 트랜잭션이 시작됐다면 가능한 한 빨리 완료하는 것이 좋습니다.

---

### 4.2.5 자동 데드락 감지

InnoDB는 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 **Wait-for List 그래프** 형태로 관리합니다. 데드락 감지 스레드가 주기적으로 이 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아 그중 하나를 강제 종료합니다. 이때 **언두 로그 레코드를 더 적게 가진 트랜잭션이 롤백 대상**으로 선택됩니다(롤백 처리 비용이 적으므로).

`innodb_table_locks` 시스템 변수를 활성화하면 레코드 잠금뿐 아니라 테이블 레벨의 잠금까지 감지할 수 있습니다.

동시 처리 스레드가 매우 많아지면 데드락 감지 스레드 자체가 느려질 수 있는데, 이 경우 `innodb_deadlock_detect`를 `OFF`로 설정하고 대신 `innodb_lock_wait_timeout`을 50초보다 훨씬 낮은 시간으로 변경하여 사용할 것을 권장합니다.

---

### 4.2.6 자동화된 장애 복구

InnoDB는 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 Partial Write 등에 대한 복구 작업을 자동으로 진행합니다.

자동 복구로 해결할 수 없는 손상이 있다면 MySQL 서버가 시작을 멈추고 종료됩니다. 이때는 `innodb_force_recovery` 시스템 변수를 설정하여 InnoDB가 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행하도록 할 수 있습니다. (로그 파일 손상 시 6, 데이터 파일 손상 시 1로 설정)

---

> **📌 PDF 읽기 참고사항**: PDF 내에 "KYOBO eBook" 워터마크가 여러 페이지에 걸쳐 텍스트 위에 겹쳐져 있어 일부 내용의 가독성이 떨어지는 부분이 있었습니다. 다만 핵심 내용 파악에는 큰 문제가 없었습니다. 또한 4.1.7 복제(Replication) 섹션은 별도 16장에서 다룬다고 언급만 되어 있어 이 정리에서는 생략했습니다.