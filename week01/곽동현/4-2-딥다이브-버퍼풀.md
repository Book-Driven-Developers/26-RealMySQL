# 4.2 InnoDB 버퍼 풀의 읽기/쓰기 성능 향상 원리

## 🎯 핵심 원리: "메모리 vs 디스크" 속도 차이

먼저 이것부터 이해해야 합니다:

| 작업 | 속도 | 비유 |
|------|------|------|
| **메모리 접근** | 나노초(ns) 단위 | 책상 위 노트에서 바로 읽기 |
| **SSD 접근** | 마이크로초(μs) 단위 | 서랍에서 찾아서 꺼내기 |
| **HDD 접근** | 밀리초(ms) 단위 | 창고에 가서 찾아오기 |

```
메모리: 100ns
SSD:    100,000ns (1,000배 느림)
HDD:    10,000,000ns (100,000배 느림)
```

**InnoDB 버퍼 풀의 목표는 간단합니다: "가능한 한 디스크를 건드리지 않는 것"**

---

## 📖 읽기 성능 향상 원리

### 시나리오 1: 버퍼 풀이 없다면?

```java
// Java 애플리케이션에서 같은 회원 정보를 10번 조회
for (int i = 0; i < 10; i++) {
    Member member = memberRepository.findById(12L);
    System.out.println(member.getName());
}
```

**버퍼 풀이 없는 세상:**
```
[요청 1] SELECT * FROM member WHERE m_id = 12
  → InnoDB: 디스크에서 페이지 읽기 (10ms 소요)

[요청 2] SELECT * FROM member WHERE m_id = 12
  → InnoDB: 또 디스크에서 페이지 읽기 (10ms 소요)

...반복...

총 소요 시간: 10ms × 10회 = 100ms
```

### 시나리오 2: 버퍼 풀이 있다면?

```
[요청 1] SELECT * FROM member WHERE m_id = 12
  → InnoDB 버퍼 풀 확인: 없음
  → 디스크에서 페이지 읽기 (10ms)
  → 버퍼 풀에 캐시 저장 ✅

[요청 2] SELECT * FROM member WHERE m_id = 12
  → InnoDB 버퍼 풀 확인: 있음! ✅
  → 메모리에서 바로 반환 (0.0001ms)

[요청 3~10] 모두 메모리에서 반환 (0.0001ms × 9)

총 소요 시간: 10ms + (0.0001ms × 9) ≈ 10ms
```

**결과: 10배 빠름!** (실제로는 훨씬 더 큰 차이)

---

## 💾 쓰기 성능 향상 원리 (더 중요!)

쓰기가 더 흥미롭습니다. **"지연 쓰기(Write-Behind)"** 전략을 사용하기 때문입니다.

### 시나리오 1: 버퍼 풀이 없다면?

```java
// 100명의 회원 정보를 업데이트
for (int i = 1; i <= 100; i++) {
    memberRepository.updateArea(i, "서울");
}
```

**버퍼 풀이 없는 세상:**
```
[요청 1] UPDATE member SET m_area='서울' WHERE m_id=1
  → 디스크에서 페이지 읽기 (10ms)
  → 데이터 변경
  → 디스크에 페이지 쓰기 (10ms)
  → 클라이언트에 완료 응답

총 소요 시간: (10ms + 10ms) × 100 = 2,000ms (2초)
```

### 시나리오 2: 버퍼 풀이 있다면?

```
[요청 1] UPDATE member SET m_area='서울' WHERE m_id=1

  1단계: 버퍼 풀에 페이지 있는지 확인
    └─ 없으면 → 디스크에서 읽어서 버퍼 풀에 로드 (10ms, 최초 1회만)
    └─ 있으면 → 스킵 (0ms)

  2단계: 버퍼 풀의 페이지만 수정 (0.0001ms)
    └─ 이 페이지를 "더티 페이지"로 표시 ✅

  3단계: 클라이언트에 즉시 완료 응답! ✅
    └─ 디스크 쓰기는 아직 안 함!

  (나중에 백그라운드 스레드가 디스크에 기록)

총 소요 시간:
  - 첫 번째 요청: 10ms (디스크 읽기) + 0.0001ms (메모리 수정) ≈ 10ms
  - 나머지 99개: 0.0001ms × 99 ≈ 0.01ms

  합계: 약 10ms
```

**결과: 200배 빠름!** (2초 → 0.01초)

---

## 🔍 더 자세히: 쓰기 과정의 단계별 분석

### UPDATE 쿼리의 전체 여정

```sql
UPDATE member SET m_area = '경기' WHERE m_id = 12;
```

#### Step 1: 포그라운드 스레드의 작업 (사용자가 기다리는 부분)

```
[1-1] InnoDB 버퍼 풀 확인
    ┌────────────────────────────────┐
    │ m_id=12 페이지가 있나요?        │
    └────────────────────────────────┘
           ↓ YES                ↓ NO
    (메모리에서 바로)      (디스크에서 읽어와서 버퍼 풀에 로드)
           ↓                        ↓
    ────────────────────────────────────
                    ↓
[1-2] 버퍼 풀의 페이지 수정
    ┌─────────────────────────────────┐
    │  InnoDB 버퍼 풀                  │
    │  ┌─────────────────┐            │
    │  │ m_id=12         │            │
    │  │ m_area=경기 (신) │ ← 메모리만 수정
    │  │ [DIRTY] 표시    │            │
    │  └─────────────────┘            │
    └─────────────────────────────────┘

[1-3] 언두 로그 기록
    ┌─────────────────────────────────┐
    │  언두 로그                       │
    │  ┌─────────────────┐            │
    │  │ m_id=12         │            │
    │  │ m_area=서울 (구) │ ← 롤백용 백업
    │  └─────────────────┘            │
    └─────────────────────────────────┘

[1-4] 리두 로그 버퍼에 기록
    ┌─────────────────────────────────┐
    │  리두 로그 버퍼 (메모리)          │
    │  "m_id=12를 '경기'로 변경"       │
    └─────────────────────────────────┘

[1-5] 클라이언트에 즉시 응답! ✅
    "UPDATE 완료!" (실제로는 디스크에 아직 안 씀!)
```

**여기까지 걸린 시간: 약 0.0001~0.001ms** (전부 메모리 작업이므로!)

---

#### Step 2: 백그라운드 스레드의 작업 (사용자는 이미 떠남)

```
[2-1] 리두 로그 버퍼 → 리두 로그 파일 (디스크)
    주기: innodb_flush_log_at_trx_commit 설정에 따라
      - 0: 1초마다
      - 1: 매 커밋마다 (가장 안전)
      - 2: 1초마다, 하지만 OS 버퍼에만 기록

[2-2] 더티 페이지 → 데이터 파일 (디스크)
    누가: Page Cleaner Thread (백그라운드)
    언제:
      - 더티 페이지 비율이 innodb_max_dirty_pages_pct_lwm (기본 10%)를 넘으면
      - LRU 리스트에서 공간이 필요할 때
      - 체크포인트 시점에

    ┌─────────────────────────────────┐
    │  InnoDB 버퍼 풀                  │
    │  ┌─────────────────┐            │
    │  │ m_id=12 [DIRTY] │────────┐   │
    │  └─────────────────┘        │   │
    └─────────────────────────────┼───┘
                                  ↓
                    ┌──────────────────────┐
                    │  데이터 파일 (디스크)  │
                    │  member.ibd          │
                    └──────────────────────┘
```

**백그라운드 작업은 사용자가 기다리지 않음!**

---

## 🎭 실전 시나리오: 대량 INSERT

```java
// 1만 건의 주문 데이터 삽입
@Transactional
public void bulkInsertOrders() {
    for (int i = 0; i < 10000; i++) {
        Order order = new Order(...);
        orderRepository.save(order);
    }
}
```

### 버퍼 풀이 없다면:
```
각 INSERT마다:
  1. 디스크에서 페이지 읽기 (10ms)
  2. 데이터 추가
  3. 디스크에 페이지 쓰기 (10ms)

총 시간: 20ms × 10,000 = 200초 (3분 20초)
```

### 버퍼 풀이 있다면:
```
[Phase 1] 포그라운드 스레드 (사용자가 기다림)

  각 INSERT마다:
    1. 버퍼 풀에서 해당 페이지 찾기
       - 없으면 디스크에서 읽어서 버퍼 풀에 로드 (최초 몇 번만)
       - 있으면 그냥 사용

    2. 버퍼 풀의 페이지에만 데이터 추가 (0.0001ms)

    3. 더티 페이지로 표시

    4. 리두 로그 버퍼에 기록 (0.0001ms)

  총 시간: 약 0.1~1초 정도
  클라이언트: "완료!" 받고 다음 작업 진행 가능 ✅

[Phase 2] 백그라운드 스레드 (사용자는 이미 떠남)

  Page Cleaner가 천천히:
    - 더티 페이지들을 모아서
    - 배치로 디스크에 쓰기
    - 순차 쓰기로 최적화

  총 시간: 10~20초 정도 (백그라운드에서)
```

**결과: 사용자 체감 속도 200배 향상!** (200초 → 1초)

---

## 🧪 질문: 만약 디스크에 쓰기 전에 서버가 죽으면?

좋은 질문입니다! 이게 바로 **리두 로그**의 역할입니다.

### 정상 케이스:
```
[시간 T1] UPDATE 실행
  → 버퍼 풀 수정 (메모리) ✅
  → 리두 로그 파일 기록 (디스크) ✅
  → 클라이언트에 "완료" 응답

[시간 T2] 아직 데이터 파일에는 안 씀

[시간 T3] 💥 서버 크래시!

[시간 T4] 서버 재시작
  → InnoDB: "리두 로그 확인해볼까?"
  → 리두 로그: "m_id=12를 '경기'로 변경했다는 기록 발견"
  → InnoDB: "그럼 데이터 파일에 반영!" ✅

결과: 데이터 손실 없음!
```

**핵심**: 리두 로그는 **순차 쓰기**라서 디스크에 기록하는 게 매우 빠릅니다!
- 데이터 파일: 랜덤 쓰기 (느림, HDD 기준 10ms)
- 리두 로그: 순차 쓰기 (빠름, HDD 기준 0.1ms)

---

## 📊 성능 비교 표

| 작업 | 버퍼 풀 없음 | 버퍼 풀 있음 | 속도 향상 |
|------|-------------|-------------|----------|
| **단일 SELECT (첫 번째)** | 10ms | 10ms | 동일 |
| **단일 SELECT (두 번째)** | 10ms | 0.0001ms | **100,000배** |
| **단일 UPDATE** | 20ms | 0.001ms | **20,000배** |
| **대량 INSERT (1만 건)** | 200초 | 1초 | **200배** |


---

## ❓ 학습 질문

### 질문 1: 버퍼 풀이 가득 차면?

> **Q**: 만약 버퍼 풀이 가득 차면 어떻게 될까요? 새로운 페이지를 읽어와야 하는데 공간이 없다면?

---

### 질문 2: 같은 페이지를 여러 번 수정하면?

> **Q**: 더티 페이지가 디스크에 기록되기 전에 같은 페이지를 여러 번 수정하면? 예를 들어:
>
> ```sql
> UPDATE member SET m_area='서울' WHERE m_id=12;  -- 1초 후
> UPDATE member SET m_area='경기' WHERE m_id=12;  -- 2초 후
> UPDATE member SET m_area='인천' WHERE m_id=12;  -- 3초 후
> -- 백그라운드 스레드가 디스크에 쓰는 건 5초 후
> ```
>
> 디스크에는 몇 번 쓰기가 발생할까요?

---

### 질문 3: SSD 환경에서의 버퍼 풀 효과

> **Q**: SSD 환경에서는 "순차 쓰기 vs 랜덤 쓰기"의 차이가 HDD보다 작다고 했는데, 그럼 SSD에서는 버퍼 풀의 쓰기 성능 향상 효과가 줄어들까요?

---

### 질문 4: 리두 로그도 결국 디스크에 쓰는 거 아닌가?

> **Q**: "디스크에 쓰기 전에 서버가 죽어도 리두 로그가 있으면 괜찮다"고 했는데, 리두 로그에 기록하는 것도 결국 디스크 접근 아닌가? 리두 로그는 어디에 어떻게 기록되는 것이며, 정말 안전한 건가?

**핵심 답변: 리두 로그도 디스크에 쓰는 거 맞다. 하지만 데이터 파일 쓰기와는 성격이 완전히 다르다.**

#### 데이터 파일 쓰기 vs 리두 로그 쓰기

```
데이터 파일 쓰기 (랜덤 쓰기):
  - 16KB짜리 페이지 전체를 써야 함
  - 디스크의 "여기저기 흩어진 위치"에 써야 함 (랜덤 I/O)
  - HDD 기준: 디스크 헤드가 물리적으로 이동해야 함 → 느림

리두 로그 쓰기 (순차 쓰기):
  - "m_id=12의 m_area를 '경기'로 변경" 같은 변경 내역만 기록 → 수 바이트~수백 바이트
  - 로그 파일 끝에 계속 이어붙이기만 함 (Append-Only, 순차 I/O)
  - HDD 기준: 디스크 헤드 이동 없음 → 빠름
```

비유:
```
데이터 파일 쓰기 = 도서관에서 책을 찾아가서 해당 페이지를 통째로 교체
리두 로그 쓰기  = 메모장 끝에 "몇 번 책, 몇 페이지, 뭘 고쳤다" 한 줄 추가
```

#### 리두 로그의 여정: 메모리 → OS 버퍼 → 디스크

리두 로그도 처음에는 **메모리(리두 로그 버퍼)**에 쓴다. 디스크로 내려보내는 시점은 `innodb_flush_log_at_trx_commit` 설정에 따라 달라진다.

```
┌──────────────────────────────────────────────────────────┐
│                  리두 로그의 여정                          │
│                                                          │
│  [메모리]                    [디스크]                      │
│  리두 로그 버퍼  ──write──→  OS 버퍼  ──fsync──→  로그 파일  │
│                                                          │
│  write = OS에게 "이거 써줘" 요청 (메모리 → OS 캐시)        │
│  fsync = OS에게 "지금 당장 디스크에 확실히 기록해" 강제 명령  │
└──────────────────────────────────────────────────────────┘
```

| 설정값 | write 시점 | fsync 시점 | 서버 죽으면? |
|-------|-----------|-----------|------------|
| **0** | 1초마다 | 1초마다 | **최대 1초치 데이터 손실** |
| **1** (기본/권장) | **매 커밋마다** | **매 커밋마다** | **손실 없음** |
| **2** | 매 커밋마다 | 1초마다 | MySQL만 죽으면 안전, **OS까지 죽으면 최대 1초 손실** |

#### 설정값 1일 때의 흐름 (기본값, 권장)

```
[클라이언트] UPDATE + COMMIT 요청
     │
     ↓
[InnoDB] 버퍼 풀 수정 (메모리)        ← 빠름
     │
     ↓
[InnoDB] 리두 로그 버퍼에 기록 (메모리)  ← 빠름
     │
     ↓
[InnoDB] 리두 로그를 디스크에 fsync!    ← 디스크 I/O 발생 (순차 쓰기라 빠름)
     │
     ↓
[InnoDB] 클라이언트에 "COMMIT 완료" 응답  ← 이 시점에 리두 로그는 디스크에 확실히 있음
     │
     ↓
[백그라운드] 나중에 더티 페이지를 데이터 파일에 기록

     💥 여기서 서버가 죽어도?
     → 리두 로그는 이미 디스크에 있으므로 복구 가능!
```

**"COMMIT 완료"라는 응답을 주기 전에 리두 로그가 디스크에 확실히 기록된다.** 이것이 핵심이다.

#### 정리

> "리두 로그에 쓰는 것도 디스크 접근이 맞다. 하지만 **COMMIT 응답을 보내기 전에 리두 로그를 디스크에 먼저 기록하기 때문에**, 클라이언트가 '성공'이라는 응답을 받은 데이터는 반드시 복구할 수 있다."

리두 로그 쓰기가 데이터 파일 쓰기보다 훨씬 빠른 이유:
- **순차 쓰기** (append-only) vs 랜덤 쓰기
- **기록량이 작다** (변경 내역만) vs 16KB 페이지 전체

---

### 질문 5: innodb_flush_log_at_trx_commit = 0은 언제 쓸 수 있을까?

> **Q**: `innodb_flush_log_at_trx_commit = 0`으로 설정하면 리두 로그를 1초마다 디스크에 쓴다. 성능은 좋아지겠지만 서버가 죽으면 최대 1초치 데이터를 잃을 수 있다. 그러면 어떤 상황에서 이 설정(0)을 감수하고 쓸 수 있을까? 데이터 손실이 허용되는 서비스가 있을까?
