# MySQL 8.0에서 Query Cache가 제거된 이유와 이후의 캐시 전략 변화

## 1. 왜 이 주제를 선택했는가

MySQL 8.0부터 “Query Cache가 제거되었다”는 설명을 자주 보게 된다. 이 문장을 처음 접했을 때, “그럼 MySQL은 이제 캐시를 사용하지 않는 건가?”라는 의문이 들었다. 하지만 실제로는 캐시가 사라진 것이 아니라, **캐시 전략이 바뀐 것**이었다. 이 문서는 Query Cache의 구조와 한계를 정리하고, 8.0 이후 MySQL이 어떤 방향으로 캐시 구조를 재설계했는지 아키텍처 관점에서 설명한다.

---

## 2. Query Cache는 무엇이었는가

Query Cache는 동일한 SELECT 쿼리의 결과를 메모리에 저장해두고, 같은 SQL이 다시 들어오면 실행 과정을 건너뛰고 결과를 그대로 반환하는 기능이었다.

예를 들어 다음과 같은 쿼리가 있다고 가정하자.

```sql
SELECT * FROM users WHERE id = 10;
```

이 쿼리가 한 번 실행되어 결과가 캐시에 저장되면, 동일한 문자열의 쿼리가 다시 들어왔을 때 MySQL은:
	•	파싱하지 않고
	•	실행 계획을 만들지 않고
	•	디스크 접근 없이

메모리에서 결과를 바로 반환했다.

읽기 전용 시스템이나 데이터 변경이 거의 없는 환경에서는 매우 빠른 응답을 제공할 수 있었다.

---

## 3. Query Cache의 동작 방식

Query Cache는 “쿼리 문자열 단위”로 동작했다.
	•	SQL 문자열이 정확히 동일해야 한다.
	•	공백, 주석이 다르면 다른 쿼리로 인식된다.
	•	Prepared Statement를 사용하면 실제 SQL 문자열이 달라져 재사용이 어려웠다.

또한 Query Cache는 특정 쿼리가 어떤 테이블을 참조하는지 기록해두었다. 그리고 해당 테이블에 변경이 발생하면 관련된 캐시를 무효화했다.

---

## 4. 왜 문제가 되었는가

### 4.1 무효화 전략의 한계

Query Cache의 가장 큰 문제는 무효화 방식이었다. 특정 테이블에 INSERT, UPDATE, DELETE가 발생하면 그 테이블을 참조한 모든 캐시가 삭제되었다.

예를 들어 users 테이블에 단 한 건의 UPDATE가 발생해도, users를 참조하는 모든 SELECT 캐시가 사라진다. 쓰기 작업이 조금이라도 많은 서비스에서는 캐시가 자주 삭제되고 다시 생성되는 일이 반복되었다. 결국 캐시 히트율은 낮아지고 관리 비용만 증가했다.

### 4.2 글로벌 락과 동시성 문제

Query Cache는 내부적으로 전역 락을 사용했다. 여러 스레드가 동시에 캐시에 접근하면 락 경합이 발생했고, CPU 코어 수가 많을수록 병목이 심해졌다. 읽기 트래픽이 많을수록 오히려 Query Cache 자체가 성능을 떨어뜨리는 경우도 있었다.

### 4.3 확장성의 문제

Query Cache는 단일 메모리 영역을 사용했다. 캐시 크기를 늘리면 탐색 비용과 단편화가 증가했고, 줄이면 효과가 약했다. 대규모 트래픽 환경에서는 안정적인 성능을 유지하기 어려웠다.

---

## 5. MySQL 8.0에서 제거된 이유

MySQL 8.0은 확장성과 동시성을 강화하는 방향으로 아키텍처를 정비했다. 글로벌 락을 줄이고, 스토리지 엔진 중심 구조를 강화했다. Query Cache는 이러한 방향성과 맞지 않았다. 결과적으로 8.0에서는 Query Cache가 완전히 제거되었다.

이는 단순히 기능을 삭제한 것이 아니라, DB 내부 결과 캐시 전략을 포기하고 역할을 재정의한 것이라고 볼 수 있다.

---

## 6. Query Cache 이후의 캐시 전략

Query Cache가 사라졌다고 해서 MySQL이 캐시를 사용하지 않는 것은 아니다. 오히려 캐시의 책임이 더 명확해졌다.

### 6.1 InnoDB Buffer Pool 중심 구조

현재 MySQL 성능의 핵심은 InnoDB Buffer Pool이다. Buffer Pool은 쿼리 결과를 저장하는 공간이 아니라, 디스크에 존재하는 데이터 페이지와 인덱스 페이지를 메모리에 캐시하는 공간이다. 즉, “결과 캐시”가 아니라 “데이터 접근을 빠르게 만드는 캐시”다.

InnoDB는 데이터를 행(row) 단위가 아니라 16KB 페이지 단위로 관리한다. 특정 행 하나를 조회하더라도 해당 페이지 전체가 메모리에 적재된다. 이후 같은 페이지에 포함된 다른 데이터 접근은 디스크 I/O 없이 처리된다. 이 구조 덕분에 반복 접근이 많은 서비스 환경에서 성능이 크게 향상된다.

Buffer Pool은 다음과 같은 페이지를 저장한다.
- 테이블 데이터 페이지
- B+Tree 인덱스 페이지
- Undo 로그 페이지
- Change Buffer 관련 페이지
- 데이터 딕셔너리 페이지

즉, InnoDB의 거의 모든 핵심 구조가 Buffer Pool을 기반으로 동작한다.

읽기 동작은 다음과 같이 이루어진다.
1. 필요한 페이지가 Buffer Pool에 존재하는지 확인한다.
2. 존재하면 즉시 반환한다(Buffer Hit).
3. 존재하지 않으면 디스크에서 읽어와 메모리에 적재한다(Buffer Miss).
4. 적재된 페이지는 LRU 리스트에 등록된다.

Buffer Pool은 단순 LRU가 아니라 Young/Old 영역으로 나뉜 변형 LRU를 사용한다. 새로 읽힌 페이지는 Old 영역에 들어가며, 반복적으로 접근되면 Young 영역으로 이동한다. 교체는 Old 영역부터 이루어진다. 이는 Full Table Scan으로 인해 기존 Hot 데이터가 밀려나는 현상을 방지하기 위한 설계이다.

또한 Buffer Pool은 읽기뿐 아니라 쓰기 성능에도 깊게 관여한다. 수정된 페이지는 즉시 디스크에 기록되지 않고 Dirty Page 상태로 메모리에 유지된다. 이후 백그라운드 스레드가 체크포인트 시점에 디스크로 flush한다. 이 과정은 쓰기 병합과 랜덤 I/O 감소를 가능하게 하여 트랜잭션 처리량을 높인다.

결과적으로 Buffer Pool은 단순한 캐시가 아니라, 디스크 I/O를 최소화하고 동시성을 유지하며 쓰기 성능까지 최적화하는 핵심 아키텍처 구성 요소라고 볼 수 있다.


Query Cache가 담당하던 “결과 캐시”는 현재 애플리케이션 계층에서 처리하는 것이 일반적이다. Redis나 Memcached 같은 외부 캐시 시스템을 사용하면 다음과 같은 장점이 있다.
	•	API 단위로 캐시 정책 설계 가능
	•	TTL 기반 관리 가능
	•	DB와 독립적으로 확장 가능
	•	무효화 전략을 서비스 로직에 맞게 설계 가능

즉, 데이터베이스는 데이터 일관성과 트랜잭션 처리에 집중하고, 결과 캐시는 애플리케이션이 담당하는 구조로 역할이 분리되었다.

---

## 7. 비교 정리

항목	Query Cache	8.0 이후 전략
캐시 대상	쿼리 결과	데이터/인덱스 페이지
무효화 단위	테이블 전체	페이지 단위
동시성	글로벌 락	세분화된 구조
확장성	낮음	높음
현재 상태	제거됨	Buffer Pool 중심


---

## 8. 결론

MySQL 8.0에서 Query Cache는 제거되었다. 그러나 이는 캐시 기능의 축소가 아니라, 더 확장 가능한 구조로의 전환이다. 쿼리 결과를 통째로 저장하는 전역 캐시 대신, InnoDB Buffer Pool을 통한 페이지 캐시 구조와 외부 캐시 시스템을 조합하는 전략이 자리 잡았다.

따라서 “MySQL 캐시는 사라졌다”는 표현은 정확하지 않다. 정확한 표현은 다음과 같다.

Query Cache는 제거되었고, MySQL의 캐시 전략은 더 확장성과 동시성을 고려한 구조로 재정립되었다.

